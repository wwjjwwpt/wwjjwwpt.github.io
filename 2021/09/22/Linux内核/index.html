<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Linux内核 | 
	 
	wenwenzi&#39;s notebook
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "wujun234.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.4.1"></head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">wenwenzi's notebook</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file active">
									<a href="/2021/09/22/Linux%E5%86%85%E6%A0%B8/">
										Linux内核
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/01/Xpath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
										Xpath学习笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/04/22/hello-world/">
										hello-world
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/03/10/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%E7%AC%94%E8%AE%B0/">
										算法小抄笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/05/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">
										算法笔记
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Linux内核
</h1>
<div class="article-meta">
	
	<span>John Doe</span>
	<span>2021-09-22 20:09:44</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h1><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>void *q q++ 报错 不知道有多长 </p>
<p>int *p p++不报错</p>
<h4 id="联合类型1、利用变色龙类型"><a href="#联合类型1、利用变色龙类型" class="headerlink" title="联合类型1、利用变色龙类型"></a>联合类型1、利用变色龙类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Variant</span>&#123;</span></span><br><span class="line"></span><br><span class="line">Char type;</span><br><span class="line"></span><br><span class="line">Union&#123;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">long</span> lval;</span><br><span class="line"><span class="type">float</span> fval&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="联合类型2、超级强制类型转换"><a href="#联合类型2、超级强制类型转换" class="headerlink" title="联合类型2、超级强制类型转换"></a>联合类型2、超级强制类型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">T</span>&#123;</span></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">&#125;</span><br><span class="line">T t;</span><br><span class="line">t.b = b;</span><br><span class="line">a = t.a;</span><br></pre></td></tr></table></figure>

<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#:表示只占一个字节</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a:<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> b:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  A x;</span><br><span class="line">  <span class="type">char</span> *p = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">  *p = <span class="number">0xdb</span></span><br><span class="line">  print(<span class="string">&quot;%d,%d&quot;</span>,<span class="keyword">sizeof</span>(A),x.a,x.b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">8</span></span><br><span class="line">  </span><br><span class="line">#成员函数不放内存</span><br><span class="line">class A&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">8</span></span><br><span class="line">  </span><br><span class="line">#不管几个虚函数函数放内存，多个<span class="keyword">sizeof</span>相同</span><br><span class="line">class A&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y ;</span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sizeof</span>(A) = <span class="number">12</span></span><br><span class="line">#其中<span class="number">4</span>个字节为vtable指向虚函数的表</span><br><span class="line">#虚函数跳转表被所有相同的嘞所共享</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WMachine</span>&#123;</span></span><br><span class="line">clashwash(WMachine *m)</span><br><span class="line">&#123;</span><br><span class="line">m-&gt;wash(衣服)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ManueWmachine 继承 Wmachine</span><br><span class="line">&#123;</span><br><span class="line">  Wash()#重写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚函数表的在多态的跳转</p>
<p>特别频繁调用不要用虚函数，查表的时间开销</p>
<h2 id="Linux虚拟内存管理"><a href="#Linux虚拟内存管理" class="headerlink" title="Linux虚拟内存管理"></a>Linux虚拟内存管理</h2><p>查表：硬件</p>
<p>初始化表&#x2F;缺页中断：操作系统</p>
<p>虚拟内存管理：A芯片不可，安卓可以</p>
<p>作用：主要作用：让每一个进程拥有自己独立的内存空间</p>
<p>​            次要作用：扩展空间</p>
<p>虚拟内存地址，不同进程互不影响，是虚拟的空间</p>
<p>宏内核：占用空间大，速度快</p>
<p>微内核：占用空间小，速度慢</p>
<p>每一个进程有一个虚拟地址的表，切换进程也在切换表</p>
<h2 id="C程序运行时的内存布局"><a href="#C程序运行时的内存布局" class="headerlink" title="C程序运行时的内存布局"></a>C程序运行时的内存布局</h2><p>栈区：函数变量，上往下</p>
<p>。。(动态库映射区) 区域大得狠</p>
<p>堆区：malloc&#x2F;free内存放在堆区，下往上</p>
<p>静态数据区：有已初始化和未初始化</p>
<p>常量数据区 带双引号放入 const</p>
<p>代码区：编译的代码</p>
<p>栈区和堆区不能碰面否则有数据泄露</p>
<p>每一个区有一个权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">#会报错</span><br></pre></td></tr></table></figure>

<h3 id="栈区的调用"><a href="#栈区的调用" class="headerlink" title="栈区的调用"></a>栈区的调用</h3><p>包含的函数：局部变量和函数的形参</p>
<h4 id="进程栈和系统栈"><a href="#进程栈和系统栈" class="headerlink" title="进程栈和系统栈"></a>进程栈和系统栈</h4><p>系统栈由编译器管理</p>
<h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><p>push op</p>
<p>pop op</p>
<p>cal Labell</p>
<p>cal op</p>
<p>ret</p>
<p>函数的参数都放在内存地址的正偏移</p>
<p>函数的实参都放在内存地址的负偏移</p>
<p>可以利用栈来快速分配内存</p>
<h3 id="静态链接库和动态链接库"><a href="#静态链接库和动态链接库" class="headerlink" title="静态链接库和动态链接库"></a>静态链接库和动态链接库</h3><p>静态库占内存几份引用几份拷贝</p>
<p>动态库装地址后映射内存空间，在动态库中</p>
<h2 id="main不是最先执行的函数"><a href="#main不是最先执行的函数" class="headerlink" title="main不是最先执行的函数"></a>main不是最先执行的函数</h2><p>扩展关键字的作用：</p>
<p>​    1）如果程序异常退出，after还是会执行</p>
<h2 id="main执行完后程序就结束？"><a href="#main执行完后程序就结束？" class="headerlink" title="main执行完后程序就结束？"></a>main执行完后程序就结束？</h2><p>进程结束后有一个退出函数链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">atexit(f)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">#挂载了函数</span><br></pre></td></tr></table></figure>

<h2 id="变量的生存期"><a href="#变量的生存期" class="headerlink" title="变量的生存期"></a>变量的生存期</h2><h3 id="静态生存期"><a href="#静态生存期" class="headerlink" title="静态生存期"></a>静态生存期</h3><h3 id="自动生存期"><a href="#自动生存期" class="headerlink" title="自动生存期"></a>自动生存期</h3><h3 id="动态生存期"><a href="#动态生存期" class="headerlink" title="动态生存期"></a>动态生存期</h3><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag</span><br><span class="line"><span class="type">void</span> <span class="title function_">onInterupt</span><span class="params">()</span>&#123;</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">voide thread1()&#123;</span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">	这个flag不改变，由于编译器直接从寄存器中提取</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">volatile</span> 让*p的时候都去内存去一次</span><br></pre></td></tr></table></figure>

<h2 id="关于静态数据区"><a href="#关于静态数据区" class="headerlink" title="关于静态数据区"></a>关于静态数据区</h2><p>1）全局变量整个运行过程地址都不会改变</p>
<p>2）对于所欲未初始化全局变量仅计数</p>
<h2 id="C程序的静态布局（ELF文件结构）"><a href="#C程序的静态布局（ELF文件结构）" class="headerlink" title="C程序的静态布局（ELF文件结构）"></a>C程序的静态布局（ELF文件结构）</h2><p>1、Linux中可执行文件遵循ELF文件格式</p>
<p>2、ELF文件中包含很多节</p>
<p>-code或。text节 编译后的机器代码</p>
<p>data节 已初始化的全局变量</p>
<p>bss节 未初始化的全局变量和静态局部变量</p>
<p>rodata节 常量</p>
<p>malloc的划分，4096一根内存页，不要4097</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/4754/maps</span><br></pre></td></tr></table></figure>

<h3 id="call和goto，call返回原命令下一条，goto不跳回"><a href="#call和goto，call返回原命令下一条，goto不跳回" class="headerlink" title="call和goto，call返回原命令下一条，goto不跳回"></a>call和goto，call返回原命令下一条，goto不跳回</h3><p>traaceback追踪调用栈</p>
<h3 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h3><p>1、需要时主动申请</p>
<p>2、堆内存在程序主动放弃之前一直保持有效</p>
<p>3、占据了进程地址绝大部分的空间</p>
<p>3、有c运行的环境管理，管理方法：批发-》零售</p>
<p>libc.so动态库</p>
<p>libc.a静态库</p>
<h3 id="堆区的管理"><a href="#堆区的管理" class="headerlink" title="堆区的管理"></a>堆区的管理</h3><p>采用批发零售的思想</p>
<p>虚拟内存来对一个程序进行批发，程序对批发的虚拟空间来进行分配采用的是空闲链表法</p>
<h4 id="空闲链表发"><a href="#空闲链表发" class="headerlink" title="空闲链表发"></a>空闲链表发</h4><h4 id="位图分配法"><a href="#位图分配法" class="headerlink" title="位图分配法"></a>位图分配法</h4><p>整个堆分配为大量的块，多少个快，多少个bit的位图</p>
<p>堆区分配不同一个单元2bit11表示head 10表示body 00表示空闲</p>
<h4 id="对象池（后面还会提及）"><a href="#对象池（后面还会提及）" class="headerlink" title="对象池（后面还会提及）"></a>对象池（后面还会提及）</h4><p>当频繁动态申请大量空间的时候可以采用</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>brk（addr）堆尾的调整</p>
<p>sbrk（incr）brk增加或减少制定数值&#x2F;当堆区不够用时</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>相关数据结构</p>
<p>进程对应函数(PID)-》task-struct任务描述符号-&gt;内存空间</p>
<p>task-struct：</p>
<p>PID：记录ID号</p>
<p>struck mm_struct *mm</p>
<p>Mm_struct:用来描述虚拟空间布局</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> state;</span><br><span class="line"><span class="type">long</span> conter; 	<span class="comment">//每来一个时钟中断，让count--1，所以COUNTER为时间片</span></span><br><span class="line"><span class="type">long</span> priority;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_mm</span> *<span class="title">mm</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>内核喜欢用unsigned来记录一个指针，有利于进行加减运算</p>
<p>栈区可以利用start_stack-env_star-arg-start</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h3><h3 id="IO-subsystem"><a href="#IO-subsystem" class="headerlink" title="IO subsystem"></a>IO subsystem</h3><p>virtual file system(如何实现一个容器)</p>
<h3 id="Memory-management-subsystem"><a href="#Memory-management-subsystem" class="headerlink" title="Memory management subsystem"></a>Memory management subsystem</h3><h3 id="Process-management-subsystem"><a href="#Process-management-subsystem" class="headerlink" title="Process management subsystem"></a>Process management subsystem</h3><h4 id="模块-module"><a href="#模块-module" class="headerlink" title="模块(module)"></a>模块(module)</h4><h3 id="Linux虚拟内核内存管理系统"><a href="#Linux虚拟内核内存管理系统" class="headerlink" title="Linux虚拟内核内存管理系统"></a>Linux虚拟内核内存管理系统</h3><p>主要为32位系统（不过时）</p>
<h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><p>1、内存模拟外存，当物理内存不够4gb，虚拟利用外存来模拟内存</p>
<p>2、主要功能为每一个进程提供一个独立的内存地址空间，让你的系统更加安全合理</p>
<h3 id="用户地址空间和内核地址空间"><a href="#用户地址空间和内核地址空间" class="headerlink" title="用户地址空间和内核地址空间"></a>用户地址空间和内核地址空间</h3><p>1、操作系统内核代码和数据存放在内核地址空间；每个进程自己私有的代码和数据存放在用户地址空间</p>
<p>2、Linux将每个进程的4GB的独立地址空间又划分为用户地址空间(0x00000000 ~ 0xBFFFFFFF)和        内核地址空间(0xC0000000 ~ 0xFFFFFFFF)两部分</p>
<p>3、虽然Linux的内核代码和数据被映射到了每个进程的地址空间中（所有进程看到的内容是相同的），但在实际的物理内存中，只有内核代码和数据的一份拷贝。</p>
<p>大内核把操作系统函数映射到独立空间</p>
<p>优点：调用效率高&#x2F;安全</p>
<p>缺点：占用空间大</p>
<p>微内核：</p>
<p>优点：健壮</p>
<p>缺点：效率低</p>
<h4 id="凤凰构架："><a href="#凤凰构架：" class="headerlink" title="凤凰构架："></a>凤凰构架：</h4><p>两个模块靠链接器到一个进程中</p>
<p>微服务：一个进程只跑一个模块，两个模块利用进程间调用来进行调用，利用你socket编程进行来进行进程间通信，设置每一个字节，现在利用http协议进行接口：soap（xml）来封装，restfukl来进行轻量级。http可扩展性好。把一个模块放到另一个模块上实现了分布式。</p>
<p>容器技术，例如一个网站24小时使用，挂了以后往常需要重启，凤凰构架将每一个模块看作一个容器</p>
<p>用一个监控程序，当服务挂了直接进行重启这个模块&#x2F;微服务</p>
<p>容器技术：为期独立生存一个运行环境</p>
<h4 id="各种地址"><a href="#各种地址" class="headerlink" title="各种地址"></a>各种地址</h4><h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><p>程序在运行过程中用来访问存储器的地址。程序员在编程时，只需知道逻辑地址，不需考虑该地址与实际物理硬件上的存储单元如何对应。编译器在编译源程序时，也只需考虑逻辑地址</p>
<h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><p>表示物理存储器中一个存储单元的实际位置，地址总线上产生的就是物理地址。（总线地址）地址总线上内容严格对应</p>
<h5 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h5><p>在实地址模式下，逻辑地址等于物理地址。在虚拟地址模式下，逻辑地址不等于物理地址，必须经过查表才能转换为物理地址，去操作数来进行计算</p>
<h5 id="线性地址："><a href="#线性地址：" class="headerlink" title="线性地址："></a>线性地址：</h5><p>2维逻辑地址变为1维地址后，叫线性地址</p>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>虚拟地址（逻辑地址）利用MMU单元-》查表-〉物理地址</p>
<p>哪里去查表？</p>
<p>表在内存操作系统来进行填表利用物理地址来填表，cpu cr3进行查映射表</p>
<h5 id="映射表如何设计："><a href="#映射表如何设计：" class="headerlink" title="映射表如何设计："></a>映射表如何设计：</h5><p>映射表两列，第一列虚拟地址。第二列物理地址</p>
<p>大小为2的32次方行，每一行8个字节64bit</p>
<p>当第一列为有序的时候，用下标来进行获取物理地址数</p>
<h5 id="算奇偶校验的时候：利用查表法一次访问一个表来获取异或的数据。"><a href="#算奇偶校验的时候：利用查表法一次访问一个表来获取异或的数据。" class="headerlink" title="算奇偶校验的时候：利用查表法一次访问一个表来获取异或的数据。"></a>算奇偶校验的时候：利用查表法一次访问一个表来获取异或的数据。</h5><h5 id="元编程：一个最小单元来进行为其他编程服务"><a href="#元编程：一个最小单元来进行为其他编程服务" class="headerlink" title="元编程：一个最小单元来进行为其他编程服务"></a>元编程：一个最小单元来进行为其他编程服务</h5><h5 id="按页映射："><a href="#按页映射：" class="headerlink" title="按页映射："></a>按页映射：</h5><p>每个进程都有独立的页表</p>
<p>进程切换的过程中也带来了，操作系统共享一个页表示</p>
<p>利用虚拟空间4GB，等大小划分一个页为2的12次方，进行按页映射</p>
<p>即物理页和虚页号的映射在表中，一共有2的20次方行，需要4个字节，多的字节需要作为标志位</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h3 id="分别编译技术与链接"><a href="#分别编译技术与链接" class="headerlink" title="分别编译技术与链接"></a>分别编译技术与链接</h3><p>动态库：只是简单的页面映射</p>
<p>静态库：复制一份</p>
<h3 id="X86处理器对VM的支持"><a href="#X86处理器对VM的支持" class="headerlink" title="X86处理器对VM的支持"></a>X86处理器对VM的支持</h3><p>1、MMU单元</p>
<p>2、32bit cpu支持2级页表</p>
<p>3、64bit支持4级页表</p>
<p>4、专用寄存器CR3 有效页目录表物理地址</p>
<p>5、专用寄存器CR2 缺页异常的线性地址</p>
<p>6、TLB缓冲区：CPU将虚拟地址转换为物理地址</p>
<h4 id="1、减少了也表本身的内存占用大小"><a href="#1、减少了也表本身的内存占用大小" class="headerlink" title="1、减少了也表本身的内存占用大小"></a>1、减少了也表本身的内存占用大小</h4><h4 id="2、共享内存对应的二级页表"><a href="#2、共享内存对应的二级页表" class="headerlink" title="2、共享内存对应的二级页表"></a>2、共享内存对应的二级页表</h4><h4 id="3、写时拷贝"><a href="#3、写时拷贝" class="headerlink" title="3、写时拷贝"></a>3、写时拷贝</h4><p>用的时候进行1&#x2F;4页表的拷贝</p>
<p>在需要时进行拷贝</p>
<h5 id="反向映射问题"><a href="#反向映射问题" class="headerlink" title="反向映射问题"></a>反向映射问题</h5><p>如何区分，共享的成员</p>
<h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><h3 id="可执行程序如何变为进程"><a href="#可执行程序如何变为进程" class="headerlink" title="可执行程序如何变为进程"></a>可执行程序如何变为进程</h3><p>对linux来说使用shell进程工具，触发一个装载器</p>
<h4 id="编程法创建进程，查系统调用"><a href="#编程法创建进程，查系统调用" class="headerlink" title="编程法创建进程，查系统调用"></a>编程法创建进程，查系统调用</h4><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>以当前进程为模版进行，子父进程共享同一套代码。从fork之后重新执行，宏观同时进行，微观上分为单或多核，时间便轮转，所有都克隆。</p>
<p>类似克隆，不是从头开始的</p>
<h4 id="并发socket服务器"><a href="#并发socket服务器" class="headerlink" title="并发socket服务器"></a>并发socket服务器</h4><p>一个链接来到，父进程创建一个子进程来服务这个链接</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>线程共享进程内存的地址空间，每个线程有一个独立栈</p>
<p>注意线程安全问题</p>
<h5 id="在linux中引入轻量进程技术-》线程"><a href="#在linux中引入轻量进程技术-》线程" class="headerlink" title="在linux中引入轻量进程技术-》线程"></a>在linux中引入轻量进程技术-》线程</h5><p>内核中提供一个内核函数，内核修改EIP，ESP，EBP寄存器来实现线程</p>
<p>线程库Pthread库，调用clone</p>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>在应用层的操作</p>
<h3 id="虚拟内存区域VMA"><a href="#虚拟内存区域VMA" class="headerlink" title="虚拟内存区域VMA"></a>虚拟内存区域VMA</h3><p>内核为其创建一个结构体 vma_struct来记录原信息，linux将所有的VMA串成链表</p>
<h3 id="线程局部存储TLS"><a href="#线程局部存储TLS" class="headerlink" title="线程局部存储TLS"></a>线程局部存储TLS</h3><p>创建半全局变量，线程存在半全局就存在，线程上下文绑定</p>
<h3 id="轻量子进程"><a href="#轻量子进程" class="headerlink" title="轻量子进程"></a>轻量子进程</h3><p>和父进程共享同一个页表，但是寄存器不同(亲儿子)，父进程消失，轻量子进程也消失了，普通子进程不消失，内部空间拷贝了一份</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>使用了SLAB分配器</p>
<h4 id="SLAB分配器"><a href="#SLAB分配器" class="headerlink" title="SLAB分配器"></a>SLAB分配器</h4><p>频繁使用和创建的对象大小相同，使用以链表为结构的分配模式，用free指针指向空白对象</p>
<p>当所有空间被用完，创建第二个4kb</p>
<h3 id="进程信号处理函数分发表"><a href="#进程信号处理函数分发表" class="headerlink" title="进程信号处理函数分发表"></a>进程信号处理函数分发表</h3><h3 id="如何判断呢一个PID是不是空闲的呢？"><a href="#如何判断呢一个PID是不是空闲的呢？" class="headerlink" title="如何判断呢一个PID是不是空闲的呢？"></a>如何判断呢一个PID是不是空闲的呢？</h3><p>定义一个pidmap_array位图，pidmap_array</p>
<p>包含32768个位，刚好放进一个页框，有用就是为零</p>
<h4 id="如何利用pid找他的task-struct"><a href="#如何利用pid找他的task-struct" class="headerlink" title="如何利用pid找他的task_struct"></a>如何利用pid找他的task_struct</h4><p>linux采用hash表来记录数据</p>
<p>i &#x3D; HASH(PID)%2046</p>
<p>hash冲突问题，为效率不用hash</p>
<p>负载均衡时采用hash函数</p>
<h4 id="0号进程，可以理解为一个内核态"><a href="#0号进程，可以理解为一个内核态" class="headerlink" title="0号进程，可以理解为一个内核态"></a>0号进程，可以理解为一个内核态</h4><p>是c语言的一个全局变量</p>
<h4 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h4><p>收割孤儿进程，上升为init进程，利用进程间的父子关系，来实现查找pid和task_sturct</p>
<h3 id="Exec函数："><a href="#Exec函数：" class="headerlink" title="Exec函数："></a>Exec函数：</h3><p>用于创建一个新的进程，新进程以另一个可执行程序为执行脚本。</p>
<p>执行后进程就消失了</p>
<p>#include&lt;unistd.h&gt;</p>
<p>int excel(const char <em>path ,const char</em>arg)</p>
<p>会覆盖当前程序</p>
<h3 id="Shell-程序："><a href="#Shell-程序：" class="headerlink" title="Shell 程序："></a>Shell 程序：</h3><p>如果用户输入的字符串和我中有合法命令，那么我就去我的目录下面去fork这个可执行文件</p>
<h3 id="Clone函数："><a href="#Clone函数：" class="headerlink" title="Clone函数："></a>Clone函数：</h3><p>提供更大的灵活性</p>
<p>可以选择性的继承父进程的资源，可以选择vfork一个和父进程共享一样的虚存空间，也可以不和父进程共享一个虚存，成为兄弟进程，和fork不同</p>
<p>可以为新的进程置顶EIP的值</p>
<h3 id="Docker容器-轻量虚拟机-vs-普通虚拟机"><a href="#Docker容器-轻量虚拟机-vs-普通虚拟机" class="headerlink" title="Docker容器(轻量虚拟机) vs 普通虚拟机"></a>Docker容器(轻量虚拟机) vs 普通虚拟机</h3><h5 id="Docker的三大技术"><a href="#Docker的三大技术" class="headerlink" title="Docker的三大技术"></a>Docker的三大技术</h5><p>Namespce技术：每一个docker有一个temp文件，进行对应的调整就是不同的docker容器看到的东西不一样</p>
<p>CGroup，对共享资源进行隔离</p>
<p>UnionFS</p>
<p>Win10制造了一个WSL来跑docker</p>
<p>wait（僵尸态）</p>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2021/12/01/Xpath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Xpath学习笔记
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2021/05/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">
                算法笔记
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">John Doe</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>